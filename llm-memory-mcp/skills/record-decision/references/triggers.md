# Record Decision - 触发场景详解

## 自动识别场景

### 场景 1：技术方案选型

**触发关键词**：

```
- 选择...框架/库/工具
- 决定使用...
- 对比...方案
- 采用...技术
- 引入...库
- ...vs...
```

**示例对话**：

```
用户："我们需要选择一个状态管理方案，Redux 还是 Zustand？"
↓
识别到：技术选型场景
↓
记录决策过程和最终选择
```

**识别正则**：

```javascript
const techSelectionPatterns = [
  /选择.*(框架|库|工具|方案)/,
  /决定使用/,
  /对比.*方案/,
  /采用.*技术/,
  /引入.*库/,
  /(\w+)\s*vs\s*(\w+)/i
];
```

---

### 场景 2：复杂 Bug 排查

**触发条件**：

- 排查时间 > 30 分钟
- 涉及多个系统/组件
- 问题根因不明显

**触发关键词**：

```
- 排查...bug/问题
- 解决了...问题
- 发现...根因/原因
- 修复...原因是
- 终于找到...
```

**示例对话**：

```
用户："终于找到内存泄漏的原因了，是 WebSocket 连接没有正确清理"
↓
识别到：Bug 排查场景
↓
记录排查过程和解决方案
```

**识别正则**：

```javascript
const bugFixPatterns = [
  /排查.*bug/i,
  /解决了.*问题/,
  /发现.*根因/,
  /修复.*原因/,
  /终于找到/,
  /原来是.*导致/
];
```

---

### 场景 3：项目规范制定

**触发关键词**：

```
- 制定...规范
- 约定...风格
- 统一...标准
- 规范...格式
- 定义...约定
```

**示例对话**：

```
用户："我们统一 API 响应格式，都使用 { code, data, message } 结构"
↓
识别到：规范制定场景
↓
记录规范内容
```

**识别正则**：

```javascript
const conventionPatterns = [
  /制定.*规范/,
  /约定.*风格/,
  /统一.*标准/,
  /规范.*格式/,
  /定义.*约定/
];
```

---

### 场景 4：可复用代码模式

**触发关键词**：

```
- 封装...方法/函数
- 抽象...逻辑
- 可复用.*模式
- 通用...组件
- 公共...工具
```

**示例对话**：

```
用户："我封装了一个通用的错误处理中间件，可以统一处理所有异常"
↓
识别到：代码模式场景
↓
记录代码模式和使用方法
```

**识别正则**：

```javascript
const patternPatterns = [
  /封装.*(方法|函数|组件)/,
  /抽象.*逻辑/,
  /可复用.*模式/,
  /通用.*(组件|方法)/,
  /公共.*(工具|函数)/
];
```

---

## 手动触发

### 触发关键词

```
- 记录这个决策
- 保存这个方案
- 把这个记下来
- 记录一下
```

### 示例对话

```
用户："记录这个决策，我们决定使用 PostgreSQL 而不是 MySQL"
↓
识别到：手动触发
↓
提取决策信息并记录
```

---

## 不触发场景

### 简单问答

```
用户："JWT 是什么？"
↓
不触发（只是询问信息）
```

### 临时记录

```
用户："记住我明天要提交代码"
↓
不触发（使用 todo-mcp）
```

### 一般性讨论

```
用户："我觉得 React 挺好用的"
↓
不触发（没有明确决策）
```

---

## 识别优先级

当多个场景同时匹配时，按以下优先级处理：

1. **手动触发** - 用户明确要求记录
2. **技术选型** - 架构决策
3. **Bug 排查** - 问题解决
4. **规范制定** - 团队约定
5. **代码模式** - 最佳实践

---

## 完整识别代码

```javascript
function identifyDecisionScenario(context) {
  // 手动触发
  if (/记录.*(决策|方案)|保存.*方案|把.*记下来/.test(context)) {
    return { type: 'manual', category: '手动记录' };
  }

  // 技术选型
  if (/选择.*(框架|库|工具)|决定使用|对比.*方案/.test(context)) {
    return { type: 'tech_selection', category: '架构决策' };
  }

  // Bug 排查
  if (/排查.*bug|解决了.*问题|发现.*根因/i.test(context)) {
    return { type: 'bug_fix', category: '问题排查' };
  }

  // 规范制定
  if (/制定.*规范|约定.*风格|统一.*标准/.test(context)) {
    return { type: 'convention', category: '设计规范' };
  }

  // 代码模式
  if (/封装.*方法|抽象.*逻辑|可复用.*模式/.test(context)) {
    return { type: 'pattern', category: '最佳实践' };
  }

  return null;  // 不触发
}
```
